package plugin

//go:generate go run github.com/rakyll/statik@v0.1.7 -src templates -include *.tmpl

import (
	"fmt"
	"io"
	"io/fs"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/pkg/errors"
	sfs "github.com/rakyll/statik/fs"
	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/cli-runtime/pkg/resource"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/klog/v2"

	_ "github.com/bergerx/kubectl-status/pkg/plugin/statik" // generated by statik
)

// indentWriter wraps io.Writer which appends a newline and appends given amount of spaces to each line.
type indentWriter struct {
	w                       io.Writer
	indent                  int
	processedInitialNewline bool
}

// Write appends n spaces before each newline, it also adds an initial newline to the beginning.
func (iw *indentWriter) Write(p []byte) (n int, err error) {
	var newP []byte
	if !iw.processedInitialNewline {
		newP = append(newP, '\n')
		for i := 0; i < iw.indent; i++ {
			newP = append(newP, ' ')
		}
		iw.processedInitialNewline = true
	}
	for _, b := range p {
		newP = append(newP, b)
		if b == '\n' {
			for i := 0; i < iw.indent; i++ {
				newP = append(newP, ' ')
			}
		}
	}
	return iw.w.Write(newP)
}

// renderEngine provides methods to build kubernetes api queries from provided cli options.
// Also holds the parsed templates.
type renderEngine struct {
	Options
	template.Template
	indent int
	Output io.Writer
}

func newRenderEngine(options Options, output io.Writer, indent int, tmpl *template.Template) (*renderEngine, error) {
	klog.V(5).InfoS("Creating new render engine instance...", "options", options, "indent", indent, "tmpl", tmpl)
	return &renderEngine{
		options,
		*tmpl,
		indent,
		&indentWriter{w: output, indent: indent},
	}, nil
}

// We don't overlay templates dynamically, we use them all in all cases, this may be inefficient and changing this
// could be beneficial in the future. But we parse them all once and re-use again for all template executions.
func getTemplate() (*template.Template, error) {
	klog.V(5).InfoS("Creating new template instance...")
	tmpl := template.
		New("templates").
		Funcs(sprig.TxtFuncMap()).
		Funcs(funcMap())
	return parseTemplates(tmpl)
}

func parseTemplates(tmpl *template.Template) (*template.Template, error) {
	klog.V(5).InfoS("Parsing template files, initiating statik fs ...", "tmpl", tmpl)
	statikFS, err := sfs.New()
	if err != nil {
		return nil, errors.WithMessage(err, "Failed initiating statikFS")
	}
	klog.V(5).InfoS("Iterating over each file in statik fs ...")
	err = sfs.Walk(statikFS, "/", func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			klog.V(3).ErrorS(err, "Error walk on statik fs", "path", path, "file", info.Name())
		}
		klog.V(5).InfoS("Processing statik fs file ...", "file", info.Name())
		if info.IsDir() || !strings.HasSuffix(info.Name(), ".tmpl") {
			return nil
		}
		fileContents, err := sfs.ReadFile(statikFS, path)
		if err != nil {
			klog.V(3).ErrorS(err, "Error reading statik fs file", "file", info.Name())
			return err
		}
		klog.V(5).InfoS("read file", "file_length", len(fileContents))
		tmpl, err = tmpl.New(info.Name()).Parse(string(fileContents))
		if err != nil {
			klog.V(3).ErrorS(err, "Error parsing template", "file", info.Name())
			return err
		}
		return nil
	})
	if err != nil {
		klog.V(3).ErrorS(err, "Error processing some templates")
		return nil, err
	}
	klog.V(5).InfoS("Finished processing all statik fs files.")
	return tmpl, nil
}

// Use kind name if such template exists in templates, else returnDefaultResource
func findTemplateName(tmpl template.Template, kind string) string {
	if tmpl.Lookup(kind) == nil {
		return "DefaultResource"
	}
	return kind
}

// This is a modified copy of resource.Builder's mappingFor method.
func (e *renderEngine) mappingFor(resourceOrKindArg string) (*meta.RESTMapping, error) {
	fullySpecifiedGVR, groupResource := schema.ParseResourceArg(resourceOrKindArg)
	gvk := schema.GroupVersionKind{}
	restMapper, err := e.ToRESTMapper()
	if err != nil {
		return nil, err
	}

	if fullySpecifiedGVR != nil {
		gvk, _ = restMapper.KindFor(*fullySpecifiedGVR)
	}
	if gvk.Empty() {
		gvk, _ = restMapper.KindFor(groupResource.WithVersion(""))
	}
	if !gvk.Empty() {
		return restMapper.RESTMapping(gvk.GroupKind(), gvk.Version)
	}

	fullySpecifiedGVK, groupKind := schema.ParseKindArg(resourceOrKindArg)
	if fullySpecifiedGVK == nil {
		gvk := groupKind.WithVersion("")
		fullySpecifiedGVK = &gvk
	}

	if !fullySpecifiedGVK.Empty() {
		if mapping, err := restMapper.RESTMapping(fullySpecifiedGVK.GroupKind(), fullySpecifiedGVK.Version); err == nil {
			return mapping, nil
		}
	}

	mapping, err := restMapper.RESTMapping(groupKind, gvk.Version)
	if err != nil {
		// if we error out here, it is because we could not match a resource or a kind
		// for the given argument. To maintain consistency with previous behavior,
		// announce that a resource type could not be found.
		// if the error is _not_ a *meta.NoKindMatchError, then we had trouble doing discovery,
		// so we should return the original error since it may help a user diagnose what is actually wrong
		if meta.IsNoMatchError(err) {
			return nil, fmt.Errorf("the server doesn't have a resource type %q", groupResource.Resource)
		}
		return nil, err
	}

	return mapping, nil
}

func (e renderEngine) namespace() (string, error) {
	namespace, _, err := e.ToRawKubeConfigLoader().Namespace()
	return namespace, err
}

func (e renderEngine) kubernetesClientSet() (*kubernetes.Clientset, error) {
	restConfig, err := e.ToRESTConfig()
	if err != nil {
		return nil, err
	}
	return kubernetes.NewForConfig(restConfig)
}

func (e renderEngine) dynamicInterface() (dynamic.Interface, error) {
	restConfig, err := e.ToRESTConfig()
	if err != nil {
		return nil, err
	}
	return dynamic.NewForConfig(restConfig)
}

// newBuilder returns an unstructured resource builder which uses the namespace from the cli parameters.
// This can be used to run further queries for related resources.
// The resulting builder will have the namespace used in the resource builder flags.
func (e renderEngine) newBuilder() *resource.Builder {
	namespace, _ := e.namespace()
	allNamespaces := e.ResourceBuilderFlags.AllNamespaces
	return resource.NewBuilder(e).
		NamespaceParam(namespace).
		DefaultNamespace().
		AllNamespaces(*allNamespaces).
		ContinueOnError().
		Unstructured().
		Latest().
		Flatten()
}

// getQueriedResources is the main entrypoint when using the cli.
func (e renderEngine) getQueriedResources(args []string) (*resource.Result, []*resource.Info, error) {
	filenameOptions := e.ResourceBuilderFlags.FileNameFlags.ToOptions()
	builder := e.newBuilder().
		FilenameParam(false, &filenameOptions).
		LabelSelectorParam(*e.ResourceBuilderFlags.LabelSelector).
		FieldSelectorParam(*e.ResourceBuilderFlags.FieldSelector).
		ResourceTypeOrNameArgs(true, args...).
		ContinueOnError()
	results := builder.Do()
	resourceInfos, err := results.Infos()
	return results, resourceInfos, err
}

func (e renderEngine) getResourceQueryResults(namespace string, args []string) *resource.Result {
	klog.V(5).InfoS("getResourceQueryResults", "namespace", namespace, "args", args)
	builder := e.newBuilder().NamespaceParam(namespace).DefaultNamespace().ResourceTypeOrNameArgs(true, args...)
	return builder.Do()
}
